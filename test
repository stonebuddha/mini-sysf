unit;
lambda x:Int. x;
lambda X. lambda x:X. x;
let x = true in x;
5 + 4;
5 - 2;
5 * 2;
4 / 3;
6 == 3;
6 >? 2;
2 <? 6;
3.2 >=? 7.;
7. <=? 3.2;
unit <> unit;
(lambda x:Bool->Bool. if x false then true else false) (lambda x:Bool. if x then false else true);
T = Int -> Int;
lambda f:T. lambda x:Int. f (f x);
(lambda X. lambda x:X. x) [All X.X->X];
{true,false};
{true,false}.1;
{true,false}.2;
lambda x:<a:Bool,b:Bool>. x;
List = lambda T. Rec X. <nil:Unit, cons:{T,X}>;
nil = lambda T. fold [List T] <nil=unit> as <nil:Unit,cons:{T, List T}>;
cons = lambda T. lambda h:T. lambda t:List T. fold [List T] <cons={h,t}> as <nil:Unit,cons:{T, List T}>;
hd = lambda T. lambda t:List T. lambda d:T.
       case unfold [List T] t of
         <nil=_> => d
       | <cons=x> => x.1;
tl = lambda T. lambda t:List T.
       case unfold [List T] t of
         <nil=_> => nil [T]
       | <cons=x> => x.2;
Opt = lambda T. <none:Unit, some:T>;
hd_err = lambda T. lambda t:List T.
           case unfold [List T] t of
             <nil=_> => <none=unit> as Opt T
           | <cons=x> => <some=x.1> as Opt T;